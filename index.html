<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; background: radial-gradient(circle, #1a0033 0%, #000 100%); overflow: hidden; color: white; font-family: 'Segoe UI', sans-serif; }
        #controls { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10; display: flex; gap: 10px; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 50px; border: 1px solid #8a2be2; }
        input { background: transparent; color: white; border: 1px solid #555; padding: 8px 15px; border-radius: 20px; outline: none; }
        button { padding: 8px 20px; cursor: pointer; background: #8a2be2; color: white; border: none; border-radius: 20px; font-weight: bold; transition: 0.3s; }
        button:hover { background: #b066ff; box-shadow: 0 0 15px #8a2be2; }
        #status { position: absolute; bottom: 10px; left: 10px; font-size: 12px; color: #888; }
        video { display: none; } /* Hide the webcam feed */
    </style>
</head>
<body>

    <div id="controls">
        <input type="text" id="textInput" value="sudip">
        <button onclick="morph()">Morph Text</button>
        <button onclick="backToSphere()">Sphere Mode</button>
    </div>
    <div id="status">Hand Tracking: <span id="track-status">Initializing...</span></div>
    <video id="video"></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/handtrackjs/dist/handtrack.min.js"></script>

    <script>
        // --- 1. Basic Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const particleCount = 8000;
        const geometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);
        const sphereArray = new Float32Array(particleCount * 3);

        // Generate Sphere
        for (let i = 0; i < particleCount; i++) {
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            const x = 160 * Math.cos(theta) * Math.sin(phi);
            const y = 160 * Math.sin(theta) * Math.sin(phi);
            const z = 160 * Math.cos(phi);
            
            posArray[i * 3] = x; posArray[i * 3 + 1] = y; posArray[i * 3 + 2] = z;
            sphereArray[i * 3] = x; sphereArray[i * 3 + 1] = y; sphereArray[i * 3 + 2] = z;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const material = new THREE.PointsMaterial({ 
            color: 0xaa00ff, size: 1.2, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending 
        });
        const points = new THREE.Points(geometry, material);
        scene.add(points);
        camera.position.z = 400;

        // --- 2. Hand Tracking Logic ---
        let handX = 0, handY = 0;
        const video = document.getElementById("video");
        const status = document.getElementById("track-status");
        let model = null;

        const modelParams = { flipHorizontal: true, maxNumBoxes: 1, scoreThreshold: 0.6 };

        handtrack.load(modelParams).then(lmodel => {
            model = lmodel;
            status.innerText = "Camera Starting...";
            handtrack.startVideo(video).then(statusVideo => {
                if (statusVideo) {
                    status.innerText = "Tracking Active - Move your hand!";
                    runDetection();
                }
            });
        });

        function runDetection() {
            model.detect(video).then(predictions => {
                if (predictions.length > 0) {
                    // Get center of hand bounding box
                    let bbox = predictions[0].bbox;
                    handX = (bbox[0] + bbox[2] / 2) - window.innerWidth / 2;
                    handY = (bbox[1] + bbox[3] / 2) - window.innerHeight / 2;
                }
                requestAnimationFrame(runDetection);
            });
        }

        // --- 3. Animation Loop (Move particles toward hand) ---
        function animate() {
            requestAnimationFrame(animate);
            
            const positions = points.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                // Thoda sa "drift" effect hand ki taraf
                positions[i * 3] += (handX * 0.5 - positions[i * 3]) * 0.02;
                positions[i * 3 + 1] += (-handY * 0.5 - positions[i * 3 + 1]) * 0.02;
            }
            points.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 4. Text Morphing Functions ---
        function morph() {
            const text = document.getElementById('textInput').value;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1000; canvas.height = 200;
            ctx.fillStyle = "white"; ctx.font = "Bold 120px Arial"; ctx.textAlign = "center";
            ctx.fillText(text, 500, 110);
            const data = ctx.getImageData(0, 0, 1000, 200).data;
            
            const pts = [];
            for (let y = 0; y < 200; y += 3) {
                for (let x = 0; x < 1000; x += 3) {
                    if (data[(y * 1000 + x) * 4] > 128) {
                        pts.push({ x: (x - 500) * 1.2, y: (y - 100) * -1.2 });
                    }
                }
            }

            const posAttr = points.geometry.attributes.position;
            for (let i = 0; i < particleCount; i++) {
                const target = pts[i % pts.length];
                gsap.to(posAttr.array, {
                    duration: 2,
                    [i * 3]: target.x, [i * 3 + 1]: target.y, [i * 3 + 2]: 0,
                    onUpdate: () => posAttr.needsUpdate = true
                });
            }
        }

        function backToSphere() {
            const posAttr = points.geometry.attributes.position;
            for (let i = 0; i < particleCount; i++) {
                gsap.to(posAttr.array, {
                    duration: 2,
                    [i * 3]: sphereArray[i * 3],
                    [i * 3 + 1]: sphereArray[i * 3 + 1],
                    [i * 3 + 2]: sphereArray[i * 3 + 2],
                    onUpdate: () => posAttr.needsUpdate = true
                });
            }
        }
    </script>
</body>
</html>
